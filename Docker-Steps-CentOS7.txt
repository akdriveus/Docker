================================================================
INSTALLATION
================================================================
# docker --version

# cd /etc/yum.repos.d

# vim docker.repo

	[dockerrepo]
	name=Docker Repository
	baseurl=https://yum.dockerproject.org/repo/main/centos/7/
	enabled=1
	gpgcheck=1
	gpgkey=https://yum.dockerproject.org/gpg

# yum update

# yum install -y docker-engine

# systemctl enable docker

# systemctl start docker
	# docker --version
	# docker images
			(shows what is installed - currently there no Base Image is installed)
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
	# logout
	$ docker images
			Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get 			http://%2Fvar%2Frun%2Fdocker.sock/v1.29/images/json: 	dial unix /var/run/docker.sock: connect: permission denied
	$ su -

# cd /var/run

	# ls -al dock*
			-rw-r--r--. 1 root root     4 Aug 10 15:57 docker.pid
			srw-rw----. 1 root docker   0 Aug 10 15:57 docker.sock <--- as a user I have to be able to connect to this file, which 			is owned by "root" and a "docker" user group

	# cat /etc/group | grep docker
			docker:x:988:		<--- no users associated with the "docker group"

# usermod -a -G docker user

	# cat /etc/group | grep docker
			docker:x:988:user	<--- the user "user" added to the group

--- relogin

$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE   <--- as a user I'm able to 			connect to the docker dameon.


====> At this point I can pull, install images and run containers as a non-privileged user on the system.


================================================================

The Docker Hub - the most common public repository I will be pulling images from.
Base Images - It all starts with a base image. This is a foundation for containers.
I have to have a Base Image in order to run containers.

Here we will pull down a couple of base images and show how we can get some information
on what they are and how they were built.
================================================================

$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE  	<--- I don't have any images 			created. Which means I can't run any containers.

$ docker search centos

$ docker pull hello-world

		$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			hello-world         latest              1815c82652c0        8 weeks ago         1.84kB

$ docker run hello-world:latest 		OR			$ docker run 1815c82652c0 <-- IMAGE ID

$ docker pull centos:centos6

$ docker pull centos

$ docker pull nginx:latest

		$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			centos              centos6             7ea307891843        6 days ago          194MB
			centos              latest              328edcd84f1b        6 days ago          193MB
			nginx               latest              b8efb18f159b        2 weeks ago         107MB
			hello-world         latest              1815c82652c0        8 weeks ago         1.84kB

$ docker inspect centos			OR			$ docker inspect 328edcd84f1b	<--- returns information about the image in JSON.


================================================================

Running Containers
================================================================

$ docker pull docker/whalesay

$ docker run docker/whalesay cowsay Hello

 _______
< Hello >
 -------
    \
     \
      \
                    ##        .
              ## ## ##       ==
           ## ## ## ##      ===
       /""""""""""""""""___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
       \______ o          __/
        \    \        __/
          \____\______/


$ docker ps		<--- Shows what containers running on my system. Process list from within the Docker daemon.

		$ docker ps -a	<--- Shows containers in the "stop" state.

<<<TextMate>>>

$ docker inspect docker/whalesay	
									} <--- to figure out what this contaner was ment to do.
$ docker inspect centos


$ docker run -it centos:latest /bin/bash
			[root@802587d087ff /]# 
			
			-i	<== run the container in the interactive mode,
			t	<== connected to my current terminal or tty
			/bin/bash	<== the name of the command that I want my container to start up with.
			
	- Beacause I'm running it iteractivelly (-i) and on my terminal (t), it's gonna automatically attach me as the root user
	in the /bin/bash prompt.
			
			"In unix terminology,
			terminal = tty = text input/output environment
			console = physical terminal
			shell = command line interpreter"
			
			"A tty command in Linux and other Unix-like operating systems is a shell command that can be entered interactively or 			as part of a script to determine whether the output for the script is a terminal (that is, to an interactive user) or 
			to some other destination such as another program or a printer"
-----			
[root@11b58a130b8a /]# yum upgrade

			Will upgrade the packages from inside of my container, and install in my container all effected applications or all 			available updates.
			
		[root@11b58a130b8a /]# exit		<== to exit from the container. And the container will be stoped beecause the ""
			
		I'm no longer working on my host OS, I'm working on my container OS.
		My container OS isn't by all means a full OS. My container only contains the libraries and dependencies that are necessary
		to run e minimum amount of probgrams that I have installed.
	
		For Example: - there are no things like SSH
				 	 - telnet
				 
	The only command that is currently running on this container, is what I started it up with in an interactive mode, which is
	/bin/bash
	


[root@11b58a130b8a /]# exit	 <== to exit from the container. And the container will be stoped beecause the "/bin/bash" was stoped.
-----

$ docker run -d centos:latest /bin/bash

			To run the container in the detoched mode. The container runs without me being connected to it.
			It executes the command /bin/bash and closes.

$ docker run -it centos:latest /bin/bash -e dowhile	 

			If I want to write a script as par of my launching it, I could say execute a command (-e) and do the "dowhile" script,
			that actually runs constently untill I exit or attached to that container.

			-e	<== execute the command

-----
$ docker run -d nginx:latest
			
		$ docker ps
		
			CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
			614baa25efa8        nginx:latest        "nginx -g 'daemon off"   47 seconds ago      Up 46 seconds       80/tcp              eloquent_torvalds
		
		
		"NGINX is a web server or proxy server. Nginx used as reverse proxy server for HTTP, HTTPS, SMTP, IMAP, POP3 protocols, on
		the other hand, it is also used for servers load balancing and HTTP Cache."
		
		
		
$ docker inspect 614baa25efa8

			"Networks": {
			                "bridge": {
			                    "IPAMConfig": null,
			                    "Links": null,
			                    "Aliases": null,
			                    "NetworkID": "ecf01c96402e152ba3e2af8fdd667d48507cf32a1ba429a88e9a38a1454f742f",
			                    "EndpointID": "5b09b8386a3f077573e4e885c36e186047938cbfff2593aa47ec9b1dd2dc2290",
			                    "Gateway": "172.17.0.1",
			                    "IPAddress": "172.17.0.2",
			                    "IPPrefixLen": 16,
			                    "IPv6Gateway": "",
			                    "GlobalIPv6Address": "",
			                    "GlobalIPv6PrefixLen": 0,
			                    "MacAddress": "02:42:ac:11:00:02"

$ ping 172.17.0.2

			PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
			64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.063 ms
			64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.041 ms
			64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.054 ms
			64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.042 ms
			^C
			--- 172.17.0.2 ping statistics ---
			4 packets transmitted, 4 received, 0% packet loss, time 2999ms
			rtt min/avg/max/mdev = 0.041/0.050/0.063/0.009 ms
			
			>>> container is pinging.

# yum install elinks

			elinks - text-based web browser.

# elinks http://172.17.0.2

			Welcome to nginx!                                            
                                                                                                        
			   If you see this page, the nginx web server is successfully installed and working. Further            
			   configuration is required.                                                                           
                                                                                                        
			   For online documentation and support please refer to nginx.org.                                      
			   Commercial support is available at nginx.com.                                                        
                                                                                                        
			   Thank you for using nginx.
			   
			   >>> NGINX web server is installed and working.


	# yum install telnet
			   
			   
$ telnet 172.17.0.2 80
			Trying 172.17.0.2...
			Connected to 172.17.0.2.
			Escape character is '^]'.
			hello
			HTTP/1.1 400 Bad Request
			Server: nginx/1.13.3
			Date: Mon, 14 Aug 2017 21:18:23 GMT
			Content-Type: text/html
			Content-Length: 173
			Connection: close

			<html>
			<head><title>400 Bad Request</title></head>
			<body bgcolor="white">
			<center><h1>400 Bad Request</h1></center>
			<hr><center>nginx/1.13.3</center>
			</body>
			</html>
			Connection closed by foreign host.
			
			>>> This is expected response on "hello". NGINX works as expected.

$ docker stop 614baa25efa8			OR			docker stop eloquent_torvalds   (eloquent_torvalds is container's NAME)

			
		$ docker ps
		
			CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS         PORTS     NAMES
				
				
		$ docker ps -a
		
			CONTAINER ID        IMAGE                COMMAND                  CREATED        STATUS       PORTS           NAMES
			614baa25efa8        nginx:latest         "nginx -g 'daemon ..."   42 minutes ago      Exited (0) 11 seconds ago 			eloquent_torvalds
		

$ docker run -d --name=MyWEB1 nginx:latest

			--name=MyWEB1	<== giving a name to my container.
			
			
		$ docker ps
		CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS        NAMES
		b07ea92af34f        nginx:latest        "nginx -g 'daemon ..."   3 minutes ago       Up 3 minutes        80/tcp      MyWEB1
		
		
		$ docker inspect MyWEB1
		

$ docker stop b07ea92af34f			OR			$ docker stop MyWEB1

================================================================

The Container Lifecycle

We need to understand the lifecycle of our containers, so we talk about how to start, stop, restart and display their state.
================================================================

$ docker run 

		OR

$ docker run -d --name=LifeCycle1 nginx:latest
			 
			 -d to run the container in the background so I can use it.


$ docker attach LifeCycle1

$ docker start LifeCycle1

$ docker restart LifeCycle1

$ docker exec -it LifeCycle1 /bin/bash		==> will allow me to execute something in a running container without affecting the
											command or the process that was started by the container when it was instanciated.
											And by stopping just executed command, I will not exiting the container itself. 
											
				-it		<== interactivelly attached
											
$ docker stop b07ea92af34f			OR			$ docker stop LifeCycle1

================================================================

Image and Container Management

We know how to pull/install images and instantiate containers. 
Removing them is equally important but there are some caveats.
================================================================

$ docker rmi centos:centos6		<-- remove image

			$ docker rmi hello-world
					Error response from daemon: conflict: unable to remove repository reference "hello-world" (must force) - 					container 752960a0e544 is using its referenced image 1815c82652c0
					
$ docker rmi -f hello-world		<--  -f force removal

++++ TYPICALLY - I'll remove the containers that are a dependency upon the base image. So, the error, is the reminder that I probably have containers that I need this image for. Or I have containers that are stopped, that are based on that base image, and I probably don't need anymore.++++

$ docker rm wonderful_easley	OR		docker rm 752960a0e544		<-- remove the container

$ docker rm name name OR ID ID		<-- to remove multiple containers

$ docker ps -a -q		<-- returns IDs of containers that are stopped on my system

			088f3391c4e3
			4e9ec3f1e384
			6cc0605acbcf
			8ef4525d1743
			a131906febd7
			0e29c0af1a2f

$ docker rm `docker ps -a -q`		<-- bash command substitute. Pass to the "remove" command IDs of all stopped containers. These 										containers will be removed.

			088f3391c4e3
			4e9ec3f1e384
			6cc0605acbcf
			8ef4525d1743
			a131906febd7
			0e29c0af1a2f
			
================================================================

Redirection - Ports and Volumes
We have the ability to redirect container ports and volumes to our host operating system for ease of use and flexibility.
================================================================

PORTS			- are exposed(openned) in a container so that I can connect them through the container 				  IP, but they have to be exposed as part of the docker file.

				
				- to combat the routing problems, I'm going to direct the port that is listening for HTTP 				  on my container (nginx), to a port on my underlying host.
				
				- the are a couple of different ways I can do that:
				

		$ docker images
				
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			centos              latest              328edcd84f1b        2 weeks ago         193MB
			nginx               latest              b8efb18f159b        3 weeks ago         107MB
			
		$ docker run -d nginx:latest
			
			91a32cd7a7332a3fade140a9bb09800cc8bf520c4bb6127a6a7bba3b63ec306f
			
		$ docker ps
		
			CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS          PORTS     NAMES
			91a32cd7a733   nginx:latest   "nginx -g 'daemon ..."   59 seconds ago  Up 58 seconds   80/tcp    kind_lalande
			
		$ docker inspect kind_lalande | grep IPAddr
			
			"SecondaryIPAddresses": null,
			            "IPAddress": "172.17.0.2",
			                    "IPAddress": "172.17.0.2",
								
								
		$ elinks http://172.17.0.2

					Welcome to nginx!                                            
                                                                                                        
					   If you see this page, the nginx web server is successfully installed and working. 
			   
					   >>> NGINX web server is installed and working.
					   
		

								
$ docker run -d --name=WebServer1 -P nginx:latest

					--> -P <-- It sayes, any ports that are exposed to my container, I want you to make available 					through the host OS on a random port between 32768 and 65000. This is a port range that is available for docker to pick randomly.

	$ docker ps
				
	  CONTAINER ID   IMAGE      COMMAND                  CREATED       STATUS           PORTS                   NAMES
	  190ef25498aa  nginx:latest "nginx -g 'daemon ..."  17 sec ago   Up 17 seconds   0.0.0.0:32768->80/tcp   WebServer1
	  
	  --> 0.0.0.0:32768->80/tcp This means that the port 32768 is bound all local interfaces. localhost as well as the IP that's assigned to this localhost. Also it is directing the traffic to port 80.
	  
	  --> I could have bound just the localhost 172.0.0.1, If I wanted to. 
	  OR, if I had multiple IP adresses on the system and multiple ethernet adapters, I could bind it to just one particuilar.
	  
$ elinks http://172.17.0.2

			Welcome to nginx!
			
$ elinks http://localhost:32768

			Welcome to nginx!
			
$ docker port WebServer1 $CONTAINERPORT
		80/tcp -> 0.0.0.0:32769
		

			$ docker stop WebServer1
			


$ docker run -d -p 8080:80 --name=WebServer2 nginx:latest	<-- Bind a local port 8080 to container port 80

	CONTAINER ID   IMAGE        COMMAND                CREATED         STATUS             PORTS                  NAMES
	79697438174e   nginx:latest "nginx -g 'daemon ..." About a minute  Up About a minute  0.0.0.0:8080->80/tcp   WebServer2

	$ docker run -d -p 8080:80, 8443:443 --name=WebServer2 nginx:latest <-- Bind multiple local ports to container ports

$ elinks http://localhost:8080
		
		Welcome to nginx!


I can mount directories from my underlieng hosts inside my container.

--- 1st Way --- The first way we can do a container that mounts a particuilar directory:

$ docker run -d -p 8080:80 --name=WebServer3 -v /mnt/data nginx:latest  
		
		17dc1e8015710e1ec198a98d3281912757fbb5f38dd10b656592f740b7423d69
		    
			<-- I've created a container that has a mount point /mnt/data inside of that container.


One of the best practicies for Docker is to maintain my docker containers portable as possible, and they should not contain things that are intendent to stick around. I should be able to launch a new container with relatively little interaction. I should just be able to run a command and start the container without having to worry about the complex configuration inside the container.

$ mkdir www

$ cd www

$ vim index.html

		<HTML>

		<HEAD></HEAD>

		<BODY>

		<HR/>
		THIS IS A TEST PAGE
		<HR/>

		</BODY>

		</HTML>

$ docker run -d -p 8080:80 --name=WebServer4 -v /home/usr/www:/usr/share/nginx/html nginx:latest

	 	- calling the "docker" daemon 
		- to "run"
		- in disconnected mode "-d"
		- mapping the host port "-p" "8080" to the container port "80"
		- calling it WebServer4 "--name=WebServer4"
		- creating a volume mount "-v" from /home/usr/www on my host to the remote container /usr/share/nginx/html
		- calling in an image "nginx:latest"
	
	51094356d865732f227bde8074f7ea3e286212d11f4eb96da92f89571747d662

 Evrytime I change my underlying file I don't have to do anything with my container.
 
 
================================================================


The Dockerfile
How to create your own base images. The Dockerfile will show you how.
================================================================

$ mkdir Builds

$ cd Builds

		$ docker images
			
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			centos              latest              328edcd84f1b        2 weeks ago         193MB
			nginx               latest              b8efb18f159b        4 weeks ago         107MB
			
		$ docker ps
		
			CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS          PORTS           NAMES
			
		
		$ docker ps -a
		
			CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS          PORTS           NAMES
			
