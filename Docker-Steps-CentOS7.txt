================================================================
INSTALLATION
================================================================
# docker --version

# cd /etc/yum.repos.d

# vim docker.repo

	[dockerrepo]
	name=Docker Repository
	baseurl=https://yum.dockerproject.org/repo/main/centos/7/
	enabled=1
	gpgcheck=1
	gpgkey=https://yum.dockerproject.org/gpg

# yum update

# yum install -y docker-engine

# systemctl enable docker

# systemctl start docker
	# docker --version
	# docker images
			(shows what is installed - currently there no Base Image is installed)
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
	# logout
	$ docker images
			Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get 			http://%2Fvar%2Frun%2Fdocker.sock/v1.29/images/json: 	dial unix /var/run/docker.sock: connect: permission denied
	$ su -

# cd /var/run

	# ls -al dock*
			-rw-r--r--. 1 root root     4 Aug 10 15:57 docker.pid
			srw-rw----. 1 root docker   0 Aug 10 15:57 docker.sock <--- as a user I have to be able to connect to this file, which 			is owned by "root" and a "docker" user group

	# cat /etc/group | grep docker
			docker:x:988:		<--- no users associated with the "docker group"

# usermod -a -G docker user

	# cat /etc/group | grep docker
			docker:x:988:user	<--- the user "user" added to the group

--- relogin

$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE   <--- as a user I'm able to 			connect to the docker dameon.


====> At this point I can pull, install images and run containers as a non-privileged user on the system.


================================================================

The Docker Hub - the most common public repository I will be pulling images from.
Base Images - It all starts with a base image. This is a foundation for containers.
I have to have a Base Image in order to run containers.

Here we will pull down a couple of base images and show how we can get some information
on what they are and how they were built.
================================================================

$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE  	<--- I don't have any images 			created. Which means I can't run any containers.

$ docker search centos

$ docker pull hello-world

		$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			hello-world         latest              1815c82652c0        8 weeks ago         1.84kB

$ docker run hello-world:latest 		OR			$ docker run 1815c82652c0 <-- IMAGE ID

$ docker pull centos:centos6

$ docker pull centos

$ docker pull nginx:latest

		$ docker images
			REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
			centos              centos6             7ea307891843        6 days ago          194MB
			centos              latest              328edcd84f1b        6 days ago          193MB
			nginx               latest              b8efb18f159b        2 weeks ago         107MB
			hello-world         latest              1815c82652c0        8 weeks ago         1.84kB

$ docker inspect centos			OR			$ docker inspect 328edcd84f1b	<--- returns information about the image in JSON.


================================================================

Running Containers
================================================================

$ docker pull docker/whalesay

$ docker run docker/whalesay cowsay Hello

 _______
< Hello >
 -------
    \
     \
      \
                    ##        .
              ## ## ##       ==
           ## ## ## ##      ===
       /""""""""""""""""___/ ===
  ~~~ {~~ ~~~~ ~~~ ~~~~ ~~ ~ /  ===- ~~~
       \______ o          __/
        \    \        __/
          \____\______/


$ docker ps		<--- Shows what containers running on my system. Process list from within the Docker daemon.

		$ docker ps -a	<--- Shows containers in the "stop" state.

<<<TextMate>>>

$ docker inspect docker/whalesay	
									} <--- to figure out what this contaner was ment to do.
$ docker inspect centos


$ docker run -it centos:latest /bin/bash
			[root@802587d087ff /]# 
			
			-i	<== run the container in the interactive mode,
			t	<== connected to my current terminal or tty
			/bin/bash	<== the name of the command that I want my container to start up with.
			
	- Beacause I'm running it iteractivelly (-i) and on my terminal (t), it's gonna automatically attach me as the root user
	in the /bin/bash prompt.
			
			"In unix terminology,
			terminal = tty = text input/output environment
			console = physical terminal
			shell = command line interpreter"
			
			"A tty command in Linux and other Unix-like operating systems is a shell command that can be entered interactively or 			as part of a script to determine whether the output for the script is a terminal (that is, to an interactive user) or 
			to some other destination such as another program or a printer"
-----			
[root@11b58a130b8a /]# yum upgrade

			Will upgrade the packages from inside of my container, and install in my container all effected applications or all 			available updates.
			
		[root@11b58a130b8a /]# exit		<== to exit from the container. And the container will be stoped beecause the ""
			
		I'm no longer working on my host OS, I'm working on my container OS.
		My container OS isn't by all means a full OS. My container only contains the libraries and dependencies that are necessary
		to run e minimum amount of probgrams that I have installed.
	
		For Example: - there are no things like SSH
				 	 - telnet
				 
	The only command that is currently running on this container, is what I started it up with in an interactive mode, which is
	/bin/bash
	


[root@11b58a130b8a /]# exit	 <== to exit from the container. And the container will be stoped beecause the "/bin/bash" was stoped.
-----

$ docker run -d centos:latest /bin/bash

			To run the container in the detoched mode. The container runs without me being connected to it.
			It executes the command /bin/bash and closes.

$ docker run -it centos:latest /bin/bash -e dowhile	 

			If I want to write a script as par of my launching it, I could say execute a command (-e) and do the "dowhile" script,
			that actually runs constently untill I exit or attached to that container.

			-e	<== execute the command

-----
$ docker run -d nginx:latest
			
		$ docker ps
		
			CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
			614baa25efa8        nginx:latest        "nginx -g 'daemon off"   47 seconds ago      Up 46 seconds       80/tcp              eloquent_torvalds
		
		
		"NGINX is a web server or proxy server. Nginx used as reverse proxy server for HTTP, HTTPS, SMTP, IMAP, POP3 protocols, on
		the other hand, it is also used for servers load balancing and HTTP Cache."
		
		
		
$ docker inspect 614baa25efa8

			"Networks": {
			                "bridge": {
			                    "IPAMConfig": null,
			                    "Links": null,
			                    "Aliases": null,
			                    "NetworkID": "ecf01c96402e152ba3e2af8fdd667d48507cf32a1ba429a88e9a38a1454f742f",
			                    "EndpointID": "5b09b8386a3f077573e4e885c36e186047938cbfff2593aa47ec9b1dd2dc2290",
			                    "Gateway": "172.17.0.1",
			                    "IPAddress": "172.17.0.2",
			                    "IPPrefixLen": 16,
			                    "IPv6Gateway": "",
			                    "GlobalIPv6Address": "",
			                    "GlobalIPv6PrefixLen": 0,
			                    "MacAddress": "02:42:ac:11:00:02"

$ ping 172.17.0.2

			PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
			64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.063 ms
			64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.041 ms
			64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.054 ms
			64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.042 ms
			^C
			--- 172.17.0.2 ping statistics ---
			4 packets transmitted, 4 received, 0% packet loss, time 2999ms
			rtt min/avg/max/mdev = 0.041/0.050/0.063/0.009 ms
			
			>>> container is pinging.

# yum install elinks

			elinks - text-based web browser.

# elinks http://172.17.0.2

			Welcome to nginx!                                            
                                                                                                        
			   If you see this page, the nginx web server is successfully installed and working. Further            
			   configuration is required.                                                                           
                                                                                                        
			   For online documentation and support please refer to nginx.org.                                      
			   Commercial support is available at nginx.com.                                                        
                                                                                                        
			   Thank you for using nginx.
			   
			   >>> NGINX web server is installed and working.


	# yum install telnet
			   
			   
$ telnet 172.17.0.2 80
			Trying 172.17.0.2...
			Connected to 172.17.0.2.
			Escape character is '^]'.
			hello
			HTTP/1.1 400 Bad Request
			Server: nginx/1.13.3
			Date: Mon, 14 Aug 2017 21:18:23 GMT
			Content-Type: text/html
			Content-Length: 173
			Connection: close

			<html>
			<head><title>400 Bad Request</title></head>
			<body bgcolor="white">
			<center><h1>400 Bad Request</h1></center>
			<hr><center>nginx/1.13.3</center>
			</body>
			</html>
			Connection closed by foreign host.
			
			>>> This is expected response on "hello". NGINX works as expected.

$ docker stop 614baa25efa8			OR			docker stop eloquent_torvalds   (eloquent_torvalds is container's NAME)

			
		$ docker ps
		CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS         PORTS     NAMES
				
				
		$ docker ps -a
		CONTAINER ID        IMAGE                COMMAND                  CREATED        STATUS       PORTS           NAMES
		614baa25efa8        nginx:latest         "nginx -g 'daemon ..."   42 minutes ago      Exited (0) 11 seconds ago 		eloquent_torvalds
		

$ docker run -d --name=MyWEB1 nginx:latest

			--name=MyWEB1	<== giving a name to my container.
			
			
		$ docker ps
		CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS        NAMES
		b07ea92af34f        nginx:latest        "nginx -g 'daemon ..."   3 minutes ago       Up 3 minutes        80/tcp      MyWEB1
		
		
		$ docker inspect MyWEB1
		

$ docker stop b07ea92af34f			OR			$ docker stop MyWEB1

================================================================

The Container Lifecycle

We need to understand the lifecycle of our containers, so we talk about how to start, stop, restart and display their state.
================================================================

$ docker run 

		OR

$ docker run -d --name=LifeCycle1 nginx:latest
			 
			 -d to run the container in the background so I can use it.


$ docker attach LifeCycle1

$ docker start LifeCycle1

$ docker restart LifeCycle1

$ docker exec -it LifeCycle1 /bin/bash		==> will allow me to execute something in a running container without affecting the
											command or the process that was started by the container when it was instanciated.
											And by stopping just executed command, I will not exiting the container itself. 
											
				-it		<== interactivelly attached
											
$ docker stop b07ea92af34f			OR			$ docker stop LifeCycle1

================================================================

Image and Container Management

We know how to pull/install images and instantiate containers. 
Removing them is equally important but there are some caveats, let's look at what we need to know!
================================================================

